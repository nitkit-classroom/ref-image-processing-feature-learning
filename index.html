<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>特徴点検出・記述アルゴリズム比較</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- React & ReactDOM (Ver 18) -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    
    <!-- Babel (for JSX) -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <style>
        ::-webkit-scrollbar { width: 8px; height: 8px; }
        ::-webkit-scrollbar-track { background: #f1f1f1; }
        ::-webkit-scrollbar-thumb { background: #c7c7cc; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #a1a1aa; }
        body { background-color: #f9fafb; font-family: sans-serif; }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useMemo } = React;
        
        // --- Icons Definitions (Embedded to remove external dependencies) ---
        // これにより "Cannot read properties of undefined (reading 'forwardRef')" エラーを回避します
        const IconBase = ({ children, className, ...props }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className} {...props}>
                {children}
            </svg>
        );

        const Icons = {
            Camera: (props) => <IconBase {...props}><path d="M14.5 4h-5L7 7H4a2 2 0 0 0-2 2v9a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2V9a2 2 0 0 0-2-2h-3l-2.5-3z"/><circle cx="12" cy="13" r="3"/></IconBase>,
            Zap: (props) => <IconBase {...props}><polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"/></IconBase>,
            Shield: (props) => <IconBase {...props}><path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"/></IconBase>,
            Move: (props) => <IconBase {...props}><polyline points="5 9 2 12 5 15"/><polyline points="9 5 12 2 15 5"/><polyline points="15 19 12 22 9 19"/><polyline points="19 9 22 12 19 15"/><line x1="2" y1="12" x2="22" y2="12"/><line x1="12" y1="2" x2="12" y2="22"/></IconBase>,
            Maximize: (props) => <IconBase {...props}><path d="M8 3H5a2 2 0 0 0-2 2v3"/><path d="M21 8V5a2 2 0 0 0-2-2h-3"/><path d="M3 16v3a2 2 0 0 0 2 2h3"/><path d="M16 21h3a2 2 0 0 0 2-2v-3"/></IconBase>,
            Target: (props) => <IconBase {...props}><circle cx="12" cy="12" r="10"/><circle cx="12" cy="12" r="6"/><circle cx="12" cy="12" r="2"/></IconBase>,
            Info: (props) => <IconBase {...props}><circle cx="12" cy="12" r="10"/><line x1="12" y1="16" x2="12" y2="12"/><line x1="12" y1="8" x2="12.01" y2="8"/></IconBase>,
            Check: (props) => <IconBase {...props}><polyline points="20 6 9 17 4 12"/></IconBase>,
            X: (props) => <IconBase {...props}><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></IconBase>,
            Minus: (props) => <IconBase {...props}><line x1="5" y1="12" x2="19" y2="12"/></IconBase>,
            Play: (props) => <IconBase {...props}><polygon points="5 3 19 12 5 21 5 3"/></IconBase>,
            Settings: (props) => <IconBase {...props}><circle cx="12" cy="12" r="3"/><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"/></IconBase>,
            Activity: (props) => <IconBase {...props}><polyline points="22 12 18 12 15 21 9 3 6 12 2 12"/></IconBase>,
            RotateCw: (props) => <IconBase {...props}><path d="M21 12a9 9 0 1 1-9-9c2.52 0 4.93 1 6.74 2.74L21 8"/><path d="M21 3v5h-5"/></IconBase>,
            ZoomIn: (props) => <IconBase {...props}><circle cx="11" cy="11" r="8"/><line x1="21" y1="21" x2="16.65" y2="16.65"/><line x1="11" y1="8" x2="11" y2="14"/><line x1="8" y1="11" x2="14" y2="11"/></IconBase>,
            RefreshCw: (props) => <IconBase {...props}><path d="M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8"/><path d="M21 3v5h-5"/><path d="M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16"/><path d="M8 16H3v5"/></IconBase>,
            BookOpen: (props) => <IconBase {...props}><path d="M2 3h6a4 4 0 0 1 4 4v14a3 3 0 0 0-3-3H2z"/><path d="M22 3h-6a4 4 0 0 0-4 4v14a3 3 0 0 1 3-3h7z"/></IconBase>,
            Code: (props) => <IconBase {...props}><polyline points="16 18 22 12 16 6"/><polyline points="8 6 2 12 8 18"/></IconBase>,
            ArrowRight: (props) => <IconBase {...props}><line x1="5" y1="12" x2="19" y2="12"/><polyline points="12 5 19 12 12 19"/></IconBase>,
            GitMerge: (props) => <IconBase {...props}><circle cx="18" cy="18" r="3"/><circle cx="6" cy="6" r="3"/><path d="M6 21V9a9 9 0 0 0 9 9"/></IconBase>,
            ArrowDown: (props) => <IconBase {...props}><line x1="12" y1="5" x2="12" y2="19"/><polyline points="19 12 12 19 5 12"/></IconBase>,
            Plus: (props) => <IconBase {...props}><line x1="12" y1="5" x2="12" y2="19"/><line x1="5" y1="12" x2="19" y2="12"/></IconBase>,
            Layers: (props) => <IconBase {...props}><polygon points="12 2 2 7 12 12 22 7 12 2"/><polyline points="2 17 12 22 22 17"/><polyline points="2 12 12 17 22 12"/></IconBase>,
            Search: (props) => <IconBase {...props}><circle cx="11" cy="11" r="8"/><line x1="21" y1="21" x2="16.65" y2="16.65"/></IconBase>,
            FileText: (props) => <IconBase {...props}><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/><polyline points="14 2 14 8 20 8"/><line x1="16" y1="13" x2="8" y2="13"/><line x1="16" y1="17" x2="8" y2="17"/><polyline points="10 9 9 9 8 9"/></IconBase>,
            Calculator: (props) => <IconBase {...props}><rect x="4" y="2" width="16" height="20" rx="2"/><line x1="8" y1="6" x2="16" y2="6"/><line x1="16" y1="14" x2="16" y2="14"/><line x1="8" y1="14" x2="8" y2="14"/><line x1="12" y1="14" x2="12" y2="14"/><line x1="16" y1="18" x2="16" y2="18"/><line x1="8" y1="18" x2="8" y2="18"/><line x1="12" y1="18" x2="12" y2="18"/></IconBase>,
            Grid3x3: (props) => <IconBase {...props}><rect x="3" y="3" width="18" height="18" rx="2"/><path d="M3 9h18"/><path d="M3 15h18"/><path d="M9 3v18"/><path d="M15 3v18"/></IconBase>,
            MousePointer2: (props) => <IconBase {...props}><path d="M3 3l7.07 16.97 2.51-7.39 7.39-2.51L3 3z"/><path d="M13 13l6 6"/></IconBase>,
            PenTool: (props) => <IconBase {...props}><path d="m12 19 7-7 3 3-7 7-3-3z"/><path d="m18 13-1.5-7.5L2 2l3.5 14.5L13 18l5-5z"/><path d="m2 2 7.586 7.586"/><circle cx="11" cy="11" r="2"/></IconBase>,
        };

        // --- Types & Helpers ---
        const createGrid = (size, fill) => {
            return Array(size).fill(0).map((_, y) => Array(size).fill(0).map((_, x) => 
                typeof fill === 'function' ? fill(x, y) : fill
            ));
        };

        const initialHarrisGrid = createGrid(7, (x, y) => {
            if (x < 3 && y < 3) return 50;
            if (x >= 3 || y >= 3) return 200;
            return 50;
        });

        const initialFastGrid = createGrid(7, (x, y) => {
            const cx = 3, cy = 3;
            const isCircle = 
                (x===3 && y===0) || (x===4 && y===0) || (x===5 && y===1) || (x===6 && y===2) ||
                (x===6 && y===3) || (x===6 && y===4) || (x===5 && y===5) || (x===4 && y===6) ||
                (x===3 && y===6) || (x===2 && y===6) || (x===1 && y===5) || (x===0 && y===4) ||
                (x===0 && y===3) || (x===0 && y===2) || (x===1 && y===1) || (x===2 && y===0);
            if (x === cx && y === cy) return 50;
            if (isCircle) return 200;
            return 100;
        });

        // --- Data Definition ---
        const algorithms = [
            {
                id: 'harris',
                name: 'Harris Corner',
                fullName: 'Harris Corner Detector',
                type: 'Detector',
                category: 'detector',
                year: 1988,
                speed: 60, 
                robustness: 40,
                rotationInvariant: true,
                scaleInvariant: false,
                description: '画像の輝度変化（勾配）を用いてコーナーを検出する古典的アルゴリズム。回転には強いが、画像の拡大縮小（スケール変化）には弱い。',
                pros: ['回転に対してロバスト', '実装が比較的容易', 'エッジとコーナーを明確に区別'],
                cons: ['スケール変化に弱い', '計算コストが少し高い', 'サブピクセル精度は追加処理が必要'],
                visualStyle: 'corner',
                simSpeed: 15,
                icon: <Icons.Target className="w-6 h-6 text-blue-500" />,
                color: 'bg-blue-50 border-blue-200',
                simNote: 'スケールを大きく変化させるとコーナーを認識できなくなります。',
                opencv: "dst = cv2.cornerHarris(gray, 2, 3, 0.04)",
                steps: [
                { title: "微分画像の計算", desc: "画像のX方向・Y方向の勾配(Ix, Iy)をSobelフィルタ等で計算します。" },
                { title: "構造テンソルの生成", desc: "各画素の周辺ウィンドウ内で、勾配の積の和(Ix², Iy², IxIy)を計算し、行列Mを作ります。" },
                { title: "コーナー応答値Rの計算", desc: "行列Mの固有値を直接求めず、行列式とトレースを用いてスコアRを算出します(R = det(M) - k(trace(M))²)。" },
                { title: "閾値処理", desc: "スコアRが閾値より大きい画素をコーナーとして抽出します。" }
                ]
            },
            {
                id: 'fast',
                name: 'FAST',
                fullName: 'Features from Accelerated Segment Test',
                type: 'Detector',
                category: 'detector',
                year: 2006,
                speed: 95,
                robustness: 20,
                rotationInvariant: false,
                scaleInvariant: false,
                description: '中心画素と周囲の円周上の画素を比較するだけの非常にシンプルなロジック。機械学習を用いて高速化されており、リアルタイム処理に最適。',
                pros: ['圧倒的に高速', '計算資源が少ない環境でも動作', 'リアルタイムSLAMなどで活躍'],
                cons: ['ノイズに弱い場合がある', '回転・スケール不変性がない', 'エッジ上の点も検出しやすい'],
                visualStyle: 'point',
                simSpeed: 2,
                icon: <Icons.Zap className="w-6 h-6 text-yellow-500" />,
                color: 'bg-yellow-50 border-yellow-200',
                simNote: '非常に高速ですが、回転やスケール変化で特徴点が不安定になります。',
                opencv: "fast = cv2.FastFeatureDetector_create()\\nkp = fast.detect(gray, None)",
                steps: [
                { title: "注目画素の選定", desc: "画像内の画素Pを選択し、その輝度Ipを取得します。" },
                { title: "円周上の画素比較", desc: "Pを中心とする半径3の円周上にある16個の画素の輝度を調査します。" },
                { title: "連続性のテスト", desc: "Ipより「明るい」または「暗い」画素が、円周上でN個（通常9〜12個）連続しているか判定します。" },
                { title: "高速化", desc: "全16画素を見ずに、まず上下左右の4点で可能性を棄却するなどの最適化が行われています。" }
                ]
            },
            {
                id: 'sift',
                name: 'SIFT',
                fullName: 'Scale-Invariant Feature Transform',
                type: 'Detector + Descriptor',
                category: 'integrated',
                year: 1999,
                speed: 20,
                robustness: 95,
                rotationInvariant: true,
                scaleInvariant: true,
                description: '画像のスケール空間で極値を探索し、勾配ヒストグラムで記述する。回転・スケール・照明変化に対して非常に強力だが、計算が重い。',
                pros: ['スケール・回転に対して非常にロバスト', '照明変化にも強い', '高精度なマッチングが可能'],
                cons: ['計算負荷が非常に高い', '特許で保護されていた（現在は失効）', 'リアルタイム処理には不向き'],
                visualStyle: 'vector_circle',
                simSpeed: 80,
                icon: <Icons.Shield className="w-6 h-6 text-purple-500" />,
                color: 'bg-purple-50 border-purple-200',
                simNote: 'どのような変形を加えても安定して追従しますが、処理時間が長くなります。',
                opencv: "sift = cv2.SIFT_create()\\nkp, des = sift.detectAndCompute(gray, None)",
                steps: [
                { title: "DoGによる極値検出", desc: "画像を様々な倍率でぼかしたDoG (Difference of Gaussian) 画像を作り、その中から極値を探します。" },
                { title: "キーポイントの洗練", desc: "不安定な点やエッジ上の点を除去し、位置をサブピクセル精度で特定します。" },
                { title: "オリエンテーション付与", desc: "キーポイント周辺の勾配方向のヒストグラムを作成し、ピークとなる方向をその特徴点の「向き」として割り当てます。これで回転不変になります。" },
                { title: "記述子の生成", desc: "キーポイント周辺を4x4のブロックに分割し、各ブロックの勾配ヒストグラムを計算。計128次元のベクトルにします。" }
                ]
            },
            {
                id: 'brief',
                name: 'BRIEF',
                fullName: 'Binary Robust Independent Elementary Features',
                type: 'Descriptor',
                category: 'descriptor',
                year: 2010,
                speed: 90,
                robustness: 30,
                rotationInvariant: false,
                scaleInvariant: false,
                description: '特徴点周辺のピクセルペアの輝度大小関係をバイナリ列（0と1）で表現する。ハミング距離で高速にマッチングできるが、単体では回転に弱い。',
                pros: ['記述子の生成・マッチングが非常に高速', 'メモリ効率が良い', 'FAST等の検出器と組み合わせて使う'],
                cons: ['回転・スケール不変性がない', '単体では特徴点検出機能を持たない'],
                visualStyle: 'binary_match',
                simSpeed: 4,
                icon: <Icons.Camera className="w-6 h-6 text-green-500" />,
                color: 'bg-green-50 border-green-200',
                simNote: '回転させるとビットパターンが変化し、マッチングに失敗します（赤色表示）。',
                opencv: "brief = cv2.xfeatures2d.BriefDescriptorExtractor_create()\\n# FAST等でkpを検出後に使用\\nkp, des = brief.compute(gray, kp)",
                steps: [
                { title: "スムージング", desc: "ノイズの影響を減らすため、特徴点周辺の画像をガウシアンカーネルで平滑化します。" },
                { title: "ペアの選択", desc: "特徴点周辺の領域内で、予め決められたパターンに従ってN組のピクセルペア(p1, p2)を選びます。" },
                { title: "バイナリテスト", desc: "各ペアについて輝度を比較し、p1 < p2 なら1、そうでなければ0と判定します。" },
                { title: "ビット列生成", desc: "上記のテスト結果を並べ、128, 256, 512ビットなどのバイナリストリング（記述子）を生成します。" }
                ]
            },
            {
                id: 'orb',
                name: 'ORB',
                fullName: 'Oriented FAST and Rotated BRIEF',
                type: 'Detector + Descriptor',
                category: 'integrated',
                year: 2011,
                speed: 80,
                robustness: 75,
                rotationInvariant: true,
                scaleInvariant: true,
                description: 'FASTに方向付けを加え、BRIEFに回転耐性を持たせた改良版。SIFTの有力な無料代替手段として開発された。速度と精度のバランスが良い。',
                pros: ['SIFT/SURFより高速', '回転・スケール不変性を持つ', '特許フリーで使いやすい'],
                cons: ['SIFTほどの極端な変形耐性はない', 'エイリアシングの影響を受けやすい'],
                visualStyle: 'vector_fast',
                simSpeed: 10,
                icon: <Icons.Maximize className="w-6 h-6 text-red-500" />,
                color: 'bg-red-50 border-red-200',
                simNote: 'SIFT同様に追従しつつ、処理速度も高速に保たれます。',
                opencv: "orb = cv2.ORB_create()\\nkp, des = orb.detectAndCompute(gray, None)",
                steps: [
                { title: "oFAST (Oriented FAST)", desc: "FASTでキーポイントを検出し、スケールピラミッドでスケール不変性を確保します。" },
                { title: "ハリススコアによる選別", desc: "検出された多数の点から、Harrisコーナースコアが高い上位N個を選抜します。" },
                { title: "方向の計算", desc: "「Intensity Centroid」法を用いて、特徴点周辺の輝度の重心を求め、中心から重心へのベクトルで方向を決定します。" },
                { title: "rBRIEF (Rotated BRIEF)", desc: "検出された方向に応じてBRIEFのペアパターンを回転させ、回転不変な記述子を生成します。" }
                ]
            }
        ];

        // --- Visual Components ---
        const StepVisual = ({ algoId, stepIndex }) => {
            const commonClass = "w-full h-24 bg-white border border-gray-100 rounded-md flex items-center justify-center relative overflow-hidden";
            
            if (algoId === 'harris') {
                if (stepIndex === 0) return (
                    <div className={commonClass}>
                    <div className="grid grid-cols-3 gap-1 opacity-20 absolute w-full h-full"><div className="bg-gray-200"></div><div className="bg-gray-300"></div><div className="bg-gray-200"></div></div>
                    <div className="z-10 flex gap-4">
                        <div className="flex flex-col items-center"><span className="text-xs font-bold">X微分</span><Icons.ArrowRight className="w-6 h-6 text-blue-500" /></div>
                        <div className="flex flex-col items-center"><span className="text-xs font-bold">Y微分</span><Icons.ArrowRight className="w-6 h-6 text-blue-500 rotate-90" /></div>
                    </div>
                    </div>
                );
                if (stepIndex === 1) return (
                    <div className={commonClass}>
                    <div className="text-center">
                        <div className="text-xs text-gray-400 mb-1">周辺ウィンドウの集計</div>
                        <div className="grid grid-cols-2 gap-px bg-gray-300 p-px rounded w-16 mx-auto">
                        <div className="bg-blue-50 p-1 text-[8px] text-center">I<sub className="scale-75">x</sub>²</div>
                        <div className="bg-blue-50 p-1 text-[8px] text-center">I<sub className="scale-75">x</sub>I<sub className="scale-75">y</sub></div>
                        <div className="bg-blue-50 p-1 text-[8px] text-center">I<sub className="scale-75">x</sub>I<sub className="scale-75">y</sub></div>
                        <div className="bg-blue-50 p-1 text-[8px] text-center">I<sub className="scale-75">y</sub>²</div>
                        </div>
                        <div className="mt-1 text-xs font-serif font-bold text-gray-600">M (行列)</div>
                    </div>
                    </div>
                );
                if (stepIndex === 2) return (
                    <div className={commonClass}>
                    <div className="flex items-end gap-1 h-16 w-32 border-l border-b border-gray-300 p-1 relative">
                        <div className="text-[9px] absolute -left-6 top-0 rotate-[-90deg]">λ2</div>
                        <div className="text-[9px] absolute right-0 -bottom-4">λ1</div>
                        <div className="absolute bottom-1 left-1 w-4 h-4 bg-gray-100 border border-gray-200 rounded-sm flex items-center justify-center text-[6px]">平</div>
                        <div className="absolute top-2 left-2 w-2 h-8 bg-yellow-100 border border-yellow-200 rounded-sm flex items-center justify-center text-[6px]"></div>
                        <div className="absolute top-2 right-2 w-8 h-8 bg-red-100 border border-red-200 rounded-full flex items-center justify-center text-[6px] font-bold text-red-800">角</div>
                    </div>
                    </div>
                );
                if (stepIndex === 3) return (
                    <div className={commonClass}>
                    <div className="flex flex-col items-center w-full px-8">
                        <div className="w-full h-8 bg-gradient-to-r from-gray-200 via-yellow-200 to-red-400 rounded relative">
                        <div className="absolute right-1/4 top-0 bottom-0 w-0.5 bg-black dashed"></div>
                        <div className="absolute -top-3 right-1/4 text-[9px] font-bold">閾値</div>
                        </div>
                        <div className="flex justify-between w-full text-[9px] mt-1 text-gray-500">
                        <span>Low</span>
                        <span>High</span>
                        </div>
                    </div>
                    </div>
                );
            }

            if (algoId === 'fast') {
                if (stepIndex === 0) return (
                    <div className={commonClass}>
                    <div className="grid grid-cols-7 gap-px bg-gray-100 p-1 rounded">
                        {Array(49).fill(0).map((_, i) => (
                        <div key={i} className={`w-2 h-2 ${i === 24 ? 'bg-yellow-500' : 'bg-white'}`}></div>
                        ))}
                    </div>
                    <div className="ml-4 text-xs font-bold text-yellow-600">P (中心)</div>
                    </div>
                );
                if (stepIndex === 1) return (
                    <div className={commonClass}>
                    <div className="relative w-16 h-16 bg-gray-50 border border-gray-200 rounded grid grid-cols-7 grid-rows-7 p-0.5 gap-px">
                        <div className="absolute inset-0 flex items-center justify-center">
                        <div className="w-2 h-2 bg-black rounded-full"></div>
                        </div>
                        <div className="absolute inset-0 border-2 border-dashed border-blue-300 rounded-full scale-75"></div>
                    </div>
                    </div>
                );
                if (stepIndex === 2) return (
                    <div className={commonClass}>
                    <div className="relative w-16 h-16 flex items-center justify-center">
                        <div className="w-2 h-2 bg-yellow-600 rounded-full z-10"></div>
                        <svg viewBox="0 0 100 100" className="absolute w-full h-full rotate-[-45deg]">
                        <path d="M 50 50 L 85 15 A 50 50 0 0 1 85 85 Z" fill="rgba(255,0,0,0.2)" stroke="red" />
                        </svg>
                        <div className="absolute text-[8px] bg-white border border-red-200 px-1 rounded -bottom-2 text-red-600 font-bold">連続N画素</div>
                    </div>
                    </div>
                );
                if (stepIndex === 3) return (
                    <div className={commonClass}>
                    <div className="relative w-16 h-16 bg-gray-50 border rounded-full flex items-center justify-center">
                        <div className="w-1 h-1 bg-black rounded-full"></div>
                        <div className="absolute text-[8px] text-green-700 font-bold bg-white/80 px-1 rounded top-1/2 -translate-y-1/2">高速チェック</div>
                    </div>
                    </div>
                );
            }

            if (algoId === 'sift') {
                if (stepIndex === 0) return (
                    <div className={commonClass}>
                    <div className="flex items-center gap-2">
                        <Icons.ArrowRight className="w-4 h-4 text-gray-400" />
                        <Icons.Target className="w-6 h-6 text-purple-600 animate-bounce" />
                    </div>
                    </div>
                );
                if (stepIndex === 2) return (
                    <div className={commonClass}>
                    <div className="relative w-16 h-16 border-2 border-gray-200 rounded-full flex items-center justify-center bg-gray-50">
                        <div className="absolute w-1 h-8 bg-purple-600 origin-bottom bottom-1/2 left-1/2 -translate-x-1/2 rotate-[45deg] flex justify-center"></div>
                    </div>
                    </div>
                );
                if (stepIndex === 3) return (
                    <div className={commonClass}>
                    <div className="grid grid-cols-4 grid-rows-4 w-16 h-16 border border-gray-300 bg-white">
                        {Array(16).fill(0).map((_,i) => (
                        <div key={i} className="border-[0.5px] border-gray-100 flex items-center justify-center">
                            <Icons.ArrowRight className="w-2 h-2 text-purple-600" style={{transform: `rotate(${Math.random()*360}deg)`}} />
                        </div>
                        ))}
                    </div>
                    </div>
                );
            }

            if (algoId === 'brief' || algoId === 'orb') {
                if (stepIndex === 1 || stepIndex === 2) return (
                    <div className={commonClass}>
                    <div className="flex items-center gap-2 font-mono text-sm">
                        <span>P1</span>
                        <span className="text-gray-400">&lt;</span>
                        <span>P2</span>
                        <Icons.ArrowRight className="w-4 h-4 text-gray-400 mx-1" />
                        <div className="w-6 h-6 bg-green-100 text-green-700 rounded flex items-center justify-center font-bold">1</div>
                    </div>
                    </div>
                );
            }

            // Fallback generic visual
            return (
                <div className={commonClass}>
                <Icons.Activity className="w-6 h-6 text-gray-300" />
                <span className="text-xs text-gray-400 ml-2">Processing...</span>
                </div>
            );
        };

        const GridCell = ({ value, x, y, onChange, readOnly, bgClass }) => {
            const [strVal, setStrVal] = useState(value.toString());

            // 親コンポーネントからの値変更を反映
            useEffect(() => {
                const currentParsed = strVal === '' ? 0 : parseInt(strVal, 10);
                // 値が実質的に変わった場合のみ更新（入力中のカーソル飛び防止）
                if (!isNaN(currentParsed) && currentParsed !== value) {
                    setStrVal(value.toString());
                }
            }, [value]);

            const handleChange = (e) => {
                const val = e.target.value;
                // Allow digits and empty string
                if (val !== '' && !/^\d+$/.test(val)) return;
                
                setStrVal(val);
                
                if (onChange) {
                    const numVal = val === '' ? 0 : Math.max(0, Math.min(255, parseInt(val, 10)));
                    onChange(x, y, numVal);
                }
            };

            const handleBlur = () => {
                if (strVal === '') {
                    setStrVal('0');
                } else {
                    setStrVal(Math.max(0, Math.min(255, parseInt(strVal, 10))).toString());
                }
            };

            return (
                <input
                    type="text"
                    value={strVal}
                    readOnly={readOnly}
                    onChange={handleChange}
                    onBlur={handleBlur}
                    onFocus={(e) => !readOnly && e.target.select()}
                    className={`w-8 h-8 text-[10px] text-center outline-none focus:bg-indigo-50 focus:ring-2 focus:ring-indigo-500 z-10 transition-colors ${bgClass} ${readOnly ? 'cursor-default' : 'cursor-text text-indigo-700 font-bold'}`}
                />
            );
        };

        const EditableGrid = ({ data, onChange, highlightIndices = [], readOnly = false }) => {
            const handleCellChange = (x, y, val) => {
                if (onChange) {
                    const newData = data.map((row, rY) => 
                        row.map((cell, rX) => (rX === x && rY === y) ? val : cell)
                    );
                    onChange(newData);
                }
            };

            return (
                <div className="flex flex-col items-center">
                    <div className="grid gap-px bg-gray-300 border border-gray-300 rounded overflow-hidden" 
                        style={{ gridTemplateColumns: `repeat(${data[0].length}, minmax(0, 1fr))` }}>
                        {data.map((row, y) => row.map((val, x) => {
                            const highlight = highlightIndices.find((h) => h.x === x && h.y === y);
                            const bgClass = highlight ? (highlight.color || 'bg-yellow-200') : 'bg-white';
                            return (
                                <GridCell 
                                    key={`${x}-${y}`}
                                    x={x} 
                                    y={y} 
                                    value={val} 
                                    onChange={readOnly ? undefined : handleCellChange} 
                                    readOnly={readOnly}
                                    bgClass={bgClass}
                                />
                            );
                        }))}
                    </div>
                </div>
            );
        };

        const HarrisPlayground = () => {
            const [grid, setGrid] = useState(initialHarrisGrid);
            const k = 0.04;
            let sumIx2 = 0, sumIy2 = 0, sumIxIy = 0;
            for(let wy = -1; wy <= 1; wy++) {
                for(let wx = -1; wx <= 1; wx++) {
                    const px = 3 + wx;
                    const py = 3 + wy;
                    const ix = (grid[py][px+1] - grid[py][px-1]) / 2;
                    const iy = (grid[py+1][px] - grid[py-1][px]) / 2;
                    sumIx2 += ix * ix; sumIy2 += iy * iy; sumIxIy += ix * iy;
                }
            }
            const det = sumIx2 * sumIy2 - sumIxIy * sumIxIy;
            const trace = sumIx2 + sumIy2;
            const r = det - k * (trace * trace);

            return (
                <div className="flex flex-col md:flex-row gap-6 mt-4 p-4 bg-blue-50/50 rounded-lg border border-blue-100">
                    <div>
                        <h5 className="text-xs font-bold text-gray-600 mb-2 flex items-center gap-1"><Icons.PenTool className="w-3 h-3"/> 入力画像 (7x7)</h5>
                        <EditableGrid data={grid} onChange={setGrid} highlightIndices={[{x:3, y:3, color: 'bg-yellow-100 ring-2 ring-yellow-400 inset'}]} />
                    </div>
                    <div className="flex-1 space-y-3">
                        <div className="bg-white p-3 rounded border shadow-sm">
                            <div className="text-[10px] text-gray-500 font-bold mb-1">計算結果 (中央3x3領域)</div>
                            <div className="grid grid-cols-3 gap-2 text-center text-xs">
                                <div className="bg-blue-50 p-1 rounded"><div>∑Ix²</div><div className="font-bold text-blue-700">{sumIx2.toFixed(0)}</div></div>
                                <div className="bg-purple-50 p-1 rounded"><div>∑IxIy</div><div className="font-bold text-purple-700">{sumIxIy.toFixed(0)}</div></div>
                                <div className="bg-blue-50 p-1 rounded"><div>∑Iy²</div><div className="font-bold text-blue-700">{sumIy2.toFixed(0)}</div></div>
                            </div>
                        </div>
                        <div className="bg-white p-3 rounded border shadow-sm flex items-center justify-between">
                            <div className="text-xs">
                                <div>det: {(det/1e6).toFixed(1)}M</div>
                                <div>trace: {(trace/1e3).toFixed(1)}k</div>
                            </div>
                            <div className={`text-right ${r > 1e8 ? 'text-red-600' : 'text-gray-400'}`}>
                                <div className="text-[10px]">Score R</div>
                                <div className="font-bold text-lg">{r.toExponential(1)}</div>
                                <div className="text-[10px] font-bold">{r > 1e8 ? "CORNER!" : r < -1e7 ? "EDGE" : "FLAT"}</div>
                            </div>
                        </div>
                    </div>
                </div>
            );
        };

        const FastPlayground = () => {
            const [grid, setGrid] = useState(initialFastGrid);
            const threshold = 50;
            const offsets = [[0,-3],[1,-3],[2,-2],[3,-1],[3,0],[3,1],[2,2],[1,3],[0,3],[-1,3],[-2,2],[-3,1],[-3,0],[-3,-1],[-2,-2],[-1,-3]];
            const cx = 3, cy = 3;
            const pVal = grid[cy][cx];
            
            const circlePixels = offsets.map(([ox, oy], i) => {
                const x = cx + ox, y = cy + oy;
                const val = grid[y][x];
                let status = 'same';
                if (val > pVal + threshold) status = 'brighter';
                if (val < pVal - threshold) status = 'darker';
                return { x, y, val, status, idx: i };
            });

            let maxCont = 0;
            const stats = [...circlePixels, ...circlePixels];
            let current = 0;
            let type = '';
            for (const p of stats) {
                if (p.status !== 'same' && (type === '' || p.status === type)) {
                    current++; type = p.status;
                } else {
                    maxCont = Math.max(maxCont, current); current = p.status !== 'same' ? 1 : 0; type = p.status !== 'same' ? p.status : '';
                }
            }
            const continuousCount = Math.max(maxCont, current);

            return (
                <div className="flex flex-col md:flex-row gap-6 mt-4 p-4 bg-yellow-50/50 rounded-lg border border-yellow-100">
                    <div>
                        <h5 className="text-xs font-bold text-gray-600 mb-2 flex items-center gap-1"><Icons.PenTool className="w-3 h-3"/> 入力画像</h5>
                        <EditableGrid data={grid} onChange={setGrid} highlightIndices={[
                            {x: cx, y: cy, color: 'bg-yellow-200 ring-2 ring-yellow-500'},
                            ...circlePixels.map(p => ({x: p.x, y: p.y, color: p.status === 'brighter' ? 'bg-red-100 text-red-600' : p.status === 'darker' ? 'bg-blue-100 text-blue-600' : 'bg-gray-50'}))
                        ]} />
                    </div>
                    <div className="flex-1 space-y-3">
                        <div className="bg-white p-3 rounded border shadow-sm">
                            <div className="text-[10px] text-gray-500 font-bold mb-2">円周上の画素判定 (閾値: {threshold})</div>
                            <div className="flex flex-wrap gap-1">
                                {circlePixels.map((p, i) => (
                                    <div key={i} className={`w-5 h-6 flex items-center justify-center text-[8px] rounded border ${p.status === 'brighter' ? 'bg-red-100 text-red-700 border-red-200' : p.status === 'darker' ? 'bg-blue-100 text-blue-700 border-blue-200' : 'bg-gray-50 text-gray-300'}`}>
                                        {p.status === 'brighter' ? 'B' : p.status === 'darker' ? 'D' : '-'}
                                    </div>
                                ))}
                            </div>
                        </div>
                        <div className={`p-3 rounded border text-center ${continuousCount >= 9 ? 'bg-green-100 text-green-800 border-green-300' : 'bg-gray-50 text-gray-500'}`}>
                            <div className="text-xs font-bold">連続数: {continuousCount} (必要: 9)</div>
                            <div className="font-bold text-sm mt-1">{continuousCount >= 9 ? "FEATURE DETECTED!" : "No Feature"}</div>
                        </div>
                    </div>
                </div>
            );
        };

        const SiftDogPlayground = () => {
            const [scale1, setScale1] = useState(createGrid(5, 100));
            const [scale2, setScale2] = useState(createGrid(5, (x,y) => (x===2 && y===2) ? 180 : 100));
            const dogGrid = scale1.map((row, y) => row.map((val, x) => scale2[y][x] - val));
            const cx = 2, cy = 2;
            const cVal = dogGrid[cy][cx];
            let isExtr = true;
            for(let y=0;y<5;y++) for(let x=0;x<5;x++) {
                if(x===cx && y===cy) continue;
                if(Math.abs(dogGrid[y][x]) >= Math.abs(cVal)) isExtr = false;
            }
            if (Math.abs(cVal) < 10) isExtr = false;

            return (
                <div className="mt-4 p-4 bg-purple-50/50 rounded-lg border border-purple-100">
                    <div className="flex justify-center gap-2 mb-4 text-center">
                        <div><div className="text-[9px] text-gray-500">Scale 1</div><EditableGrid data={scale1} onChange={setScale1} /></div>
                        <div className="flex items-center text-gray-400"><Icons.Minus className="w-4 h-4"/></div>
                        <div><div className="text-[9px] text-gray-500">Scale 2</div><EditableGrid data={scale2} onChange={setScale2} /></div>
                        <div className="flex items-center text-gray-400"><Icons.ArrowRight className="w-4 h-4"/></div>
                        <div><div className="text-[9px] text-purple-700 font-bold">DoG</div><EditableGrid data={dogGrid} readOnly highlightIndices={isExtr ? [{x:2, y:2, color: 'bg-purple-200 ring-2 ring-purple-500'}] : []} /></div>
                    </div>
                    <div className={`text-center text-xs font-bold ${isExtr ? 'text-green-600' : 'text-gray-400'}`}>
                        中央(2,2)のDoG値 {cVal} は極値{isExtr ? "です (検出！)" : "ではありません"}
                    </div>
                </div>
            );
        };

        const HistogramPlayground = () => {
            const [grid, setGrid] = useState(createGrid(5, (x,y) => x * 40 + y * 40));
            const bins = Array(8).fill(0);
            for(let y=1; y<4; y++) for(let x=1; x<4; x++) {
                const dx = grid[y][x+1] - grid[y][x-1];
                const dy = grid[y+1][x] - grid[y-1][x];
                const mag = Math.sqrt(dx*dx + dy*dy);
                let angle = Math.atan2(dy, dx) * (180 / Math.PI);
                if (angle < 0) angle += 360;
                bins[Math.floor(angle / 45) % 8] += mag;
            }
            const max = Math.max(...bins, 1);

            return (
                <div className="flex gap-6 mt-4 p-4 bg-gray-50 rounded-lg border border-gray-200">
                    <div>
                        <h5 className="text-xs font-bold text-gray-600 mb-2">入力パッチ</h5>
                        <EditableGrid data={grid} onChange={setGrid} />
                    </div>
                    <div className="flex-1 flex flex-col justify-end h-32">
                        <h5 className="text-xs font-bold text-gray-600 mb-2 text-center">勾配方向ヒストグラム (Orientation)</h5>
                        <div className="flex items-end justify-between h-full gap-1">
                            {bins.map((val, i) => (
                                <div key={i} className="flex-1 flex flex-col items-center group relative">
                                    <div className="w-full bg-indigo-500 rounded-t hover:bg-indigo-600 transition-all" style={{height: `${(val/max)*100}%`, minHeight:'2px'}}></div>
                                    <div className="text-[8px] mt-1 text-gray-500">{i*45}°</div>
                                    <div className="absolute -top-4 text-[9px] bg-black text-white px-1 rounded opacity-0 group-hover:opacity-100">{val.toFixed(0)}</div>
                                </div>
                            ))}
                        </div>
                    </div>
                </div>
            );
        };

        const SimulationCanvas = ({ algoId, rotation, scale }) => {
            const canvasRef = useRef(null);
            const [metrics, setMetrics] = useState({ processingTime: 0, points: 0, status: 'Stable' });
            const algo = algorithms.find(a => a.id === algoId);

            useEffect(() => {
                if (!algo || !canvasRef.current) return;
                const ctx = canvasRef.current.getContext('2d');
                if (!ctx) return;

                const width = canvasRef.current.width;
                const height = canvasRef.current.height;
                const centerX = width / 2;
                const centerY = height / 2;

                ctx.clearRect(0, 0, width, height);
                
                ctx.strokeStyle = '#f0f0f0'; ctx.lineWidth = 1;
                for(let i=0; i<width; i+=20) { ctx.beginPath(); ctx.moveTo(i,0); ctx.lineTo(i,height); ctx.stroke(); }
                for(let i=0; i<height; i+=20) { ctx.beginPath(); ctx.moveTo(0,i); ctx.lineTo(width,i); ctx.stroke(); }

                const baseSize = 80;
                const points = [{x: -baseSize, y: -baseSize}, {x: baseSize, y: -baseSize}, {x: baseSize, y: baseSize}, {x: -baseSize, y: baseSize}];
                const rad = (rotation * Math.PI) / 180;
                const cos = Math.cos(rad), sin = Math.sin(rad);
                const transform = (p) => ({
                    x: (p.x * scale * cos - p.y * scale * sin) + centerX,
                    y: (p.x * scale * sin + p.y * scale * cos) + centerY
                });
                const tPoints = points.map(transform);

                ctx.beginPath();
                ctx.moveTo(tPoints[0].x, tPoints[0].y);
                tPoints.forEach((p, i) => { if(i>0) ctx.lineTo(p.x, p.y) });
                ctx.closePath();
                ctx.strokeStyle = '#333'; ctx.lineWidth = 2; ctx.fillStyle = 'rgba(200, 200, 200, 0.2)';
                ctx.fill(); ctx.stroke();

                let isStable = true;
                if (!algo.rotationInvariant && Math.abs(rotation % 360) > 15) isStable = false;
                if (!algo.scaleInvariant && (scale < 0.8 || scale > 1.2)) isStable = false;
                if (algo.id === 'harris' && (scale < 0.7 || scale > 1.3)) isStable = false; 

                tPoints.forEach(p => {
                    if (!isStable) {
                        ctx.fillStyle = 'rgba(255, 0, 0, 0.5)';
                        ctx.beginPath(); ctx.arc(p.x, p.y, 5, 0, Math.PI * 2); ctx.fill();
                        return;
                    }
                    ctx.fillStyle = '#00ff00'; ctx.strokeStyle = '#008800';
                    if (algo.visualStyle === 'corner') {
                        ctx.strokeRect(p.x - 6, p.y - 6, 12, 12); ctx.fillRect(p.x - 6, p.y - 6, 12, 12);
                    } else if (algo.visualStyle === 'vector_circle') {
                        const s = 10 * scale;
                        ctx.beginPath(); ctx.arc(p.x, p.y, s, 0, Math.PI*2); ctx.stroke();
                        ctx.beginPath(); ctx.moveTo(p.x, p.y); ctx.lineTo(p.x + s * Math.cos(rad), p.y + s * Math.sin(rad)); ctx.stroke();
                    } else {
                        ctx.beginPath(); ctx.arc(p.x, p.y, 4, 0, Math.PI*2); ctx.fill();
                    }
                });

                setMetrics({
                    processingTime: Math.round((algo.simSpeed * (algo.id === 'sift' ? scale : 1)) * 10) / 10,
                    points: isStable ? 4 : 0,
                    status: isStable ? '安定 (Stable)' : '検出失敗 / 不安定'
                });
            }, [algoId, rotation, scale]);

            return (
                <div className="relative bg-gray-900 rounded-lg overflow-hidden flex-grow shadow-inner border border-gray-700 h-64 w-full">
                    <canvas ref={canvasRef} width={400} height={256} className="w-full h-full object-contain" />
                    <div className="absolute top-2 left-2 text-[10px] font-mono text-green-400 bg-black/70 p-2 rounded">
                        <div>TIME: {metrics.processingTime} ms</div>
                        <div className={metrics.status.includes('安定') ? 'text-blue-400' : 'text-red-500'}>{metrics.status}</div>
                    </div>
                </div>
            );
        };

        const FeatureComparisonApp = () => {
            const [activeTab, setActiveTab] = useState('info');
            const [selectedAlgoId, setSelectedAlgoId] = useState(null);
            
            const [simAlgoId, setSimAlgoId] = useState('harris');
            const [rotation, setRotation] = useState(0);
            const [scale, setScale] = useState(1);
            const [isAutoRotate, setIsAutoRotate] = useState(false);

            const [learnAlgoId, setLearnAlgoId] = useState('harris');

            const selectedAlgo = algorithms.find(a => a.id === selectedAlgoId) || algorithms[0];
            const simAlgo = algorithms.find(a => a.id === simAlgoId) || algorithms[0];
            const learnAlgo = algorithms.find(a => a.id === learnAlgoId) || algorithms[0];

            useEffect(() => {
                let interval;
                if (isAutoRotate) {
                    interval = setInterval(() => setRotation(p => (p + 1) % 360), 30);
                }
                return () => clearInterval(interval);
            }, [isAutoRotate]);

            const detectors = algorithms.filter(a => a.category === 'detector');
            const descriptors = algorithms.filter(a => a.category === 'descriptor');
            const integrated = algorithms.filter(a => a.category === 'integrated');

            const renderAlgoRow = (algo) => (
                <tr key={algo.id} onClick={() => setSelectedAlgoId(algo.id)} className={`cursor-pointer hover:bg-indigo-50 ${selectedAlgoId === algo.id ? 'bg-indigo-50' : ''}`}>
                    <td className="px-4 py-2 font-bold text-indigo-900 flex items-center gap-2">{algo.icon}{algo.name}</td>
                    <td className="px-4 py-2 text-center">{algo.rotationInvariant ? <Icons.Check className="w-4 h-4 mx-auto text-green-500"/> : <Icons.X className="w-4 h-4 mx-auto text-red-400"/>}</td>
                    <td className="px-4 py-2 text-center">{algo.scaleInvariant ? <Icons.Check className="w-4 h-4 mx-auto text-green-500"/> : <Icons.X className="w-4 h-4 mx-auto text-red-400"/>}</td>
                    <td className="px-4 py-2 text-xs text-gray-500 hidden sm:table-cell">{algo.simSpeed < 10 ? "超高速" : "中〜低速"}</td>
                </tr>
            );

            return (
                <div className="min-h-screen bg-gray-50 p-4 md:p-8 font-sans text-gray-800">
                    <div className="max-w-6xl mx-auto mb-6">
                        <div className="text-center mb-6">
                            <h1 className="text-3xl font-bold text-indigo-900 mb-1">特徴点検出・記述アルゴリズム比較</h1>
                            <p className="text-gray-600 text-sm">仕組みの理解から数値実験、ロバスト性の検証まで</p>
                        </div>

                        <div className="flex justify-center mb-6 overflow-x-auto">
                            <div className="bg-white p-1 rounded-lg shadow border inline-flex whitespace-nowrap">
                                {[
                                    { id: 'info', icon: <Icons.Info className="w-4 h-4"/>, label: '解説・比較' },
                                    { id: 'relation', icon: <Icons.GitMerge className="w-4 h-4"/>, label: '関係性マップ' },
                                    { id: 'learn', icon: <Icons.BookOpen className="w-4 h-4"/>, label: '仕組みを学ぶ (実験室)' },
                                    { id: 'sim', icon: <Icons.Activity className="w-4 h-4"/>, label: 'シミュレーション' },
                                ].map(tab => (
                                    <button key={tab.id} onClick={() => setActiveTab(tab.id)}
                                        className={`px-4 py-2 rounded text-sm font-medium flex items-center gap-2 transition-all ${activeTab === tab.id ? 'bg-indigo-600 text-white shadow' : 'text-gray-600 hover:bg-gray-50'}`}>
                                        {tab.icon}{tab.label}
                                    </button>
                                ))}
                            </div>
                        </div>

                        {activeTab === 'info' && (
                            <div className="grid grid-cols-1 lg:grid-cols-3 gap-6 animate-in fade-in duration-500">
                                <div className="lg:col-span-2 space-y-6">
                                    <div className="bg-white rounded-xl shadow p-6 border border-gray-100">
                                        <h2 className="text-lg font-bold mb-4 flex items-center gap-2"><Icons.Move className="w-5 h-5 text-indigo-600"/> 性能ポジショニングマップ</h2>
                                        <div className="relative w-full h-64 bg-gray-50 rounded border p-4 select-none">
                                            <div className="absolute top-2 left-1/2 -translate-x-1/2 text-[10px] font-bold text-gray-400 bg-white px-2 rounded border">ロバスト性 (高)</div>
                                            <div className="absolute bottom-2 left-1/2 -translate-x-1/2 text-[10px] font-bold text-gray-400">ロバスト性 (低)</div>
                                            <div className="absolute right-2 top-1/2 -translate-y-1/2 -rotate-90 text-[10px] font-bold text-gray-400">速度 (速)</div>
                                            <div className="absolute left-2 top-1/2 -translate-y-1/2 -rotate-90 text-[10px] font-bold text-gray-400">速度 (遅)</div>
                                            <div className="absolute inset-4 border-l border-b border-gray-300"></div>
                                            {algorithms.map(algo => (
                                                <button key={algo.id} onClick={() => setSelectedAlgoId(algo.id)} className={`absolute transform -translate-x-1/2 translate-y-1/2 transition-all hover:scale-110 ${selectedAlgoId === algo.id ? 'scale-125 z-10' : ''}`} style={{left: `${algo.speed}%`, bottom: `${algo.robustness}%`}}>
                                                    <div className={`w-8 h-8 rounded-full shadow flex items-center justify-center border-2 ${selectedAlgoId === algo.id ? 'bg-indigo-50 border-indigo-600' : 'bg-white border-white'}`}>{algo.icon}</div>
                                                    <div className="text-[10px] font-bold bg-white/80 px-1 rounded shadow-sm mt-1 whitespace-nowrap">{algo.name}</div>
                                                </button>
                                            ))}
                                        </div>
                                    </div>
                                    <div className="bg-white rounded-xl shadow overflow-hidden border border-gray-100">
                                        <div className="p-3 bg-gray-50 border-b font-bold text-gray-700 flex items-center gap-2"><Icons.Layers className="w-4 h-4"/> 機能比較</div>
                                        <table className="w-full text-sm text-left">
                                            <thead className="bg-white text-gray-500 font-medium border-b">
                                                <tr><th className="px-4 py-2">名前</th><th className="px-4 py-2 text-center">回転不変</th><th className="px-4 py-2 text-center">スケール不変</th><th className="px-4 py-2 hidden sm:table-cell">速度</th></tr>
                                            </thead>
                                            <tbody className="divide-y divide-gray-100">
                                                <tr className="bg-blue-50/50"><td colSpan="4" className="px-4 py-1 text-xs font-bold text-blue-600 uppercase flex gap-2"><Icons.Search className="w-3 h-3"/> 検出器 (Detector)</td></tr>
                                                {detectors.map(renderAlgoRow)}
                                                <tr className="bg-green-50/50"><td colSpan="4" className="px-4 py-1 text-xs font-bold text-green-600 uppercase flex gap-2"><Icons.FileText className="w-3 h-3"/> 記述子 (Descriptor)</td></tr>
                                                {descriptors.map(renderAlgoRow)}
                                                <tr className="bg-purple-50/50"><td colSpan="4" className="px-4 py-1 text-xs font-bold text-purple-600 uppercase flex gap-2"><Icons.Layers className="w-3 h-3"/> 統合型 (Integrated)</td></tr>
                                                {integrated.map(renderAlgoRow)}
                                            </tbody>
                                        </table>
                                    </div>
                                </div>
                                <div className="lg:col-span-1">
                                    <div className={`h-full bg-white rounded-xl shadow border-t-4 transition-all flex flex-col ${selectedAlgoId === 'harris' ? 'border-blue-500' : selectedAlgoId === 'fast' ? 'border-yellow-500' : selectedAlgoId === 'sift' ? 'border-purple-500' : 'border-green-500'}`}>
                                        <div className={`p-5 ${selectedAlgo.color}`}>
                                            <div className="flex justify-between mb-2"><div className="p-2 bg-white rounded shadow-sm">{selectedAlgo.icon}</div><span className="text-xs font-mono text-gray-500 bg-white/50 px-2 py-1 rounded">{selectedAlgo.year}年</span></div>
                                            <h2 className="text-xl font-bold text-gray-900">{selectedAlgo.name}</h2>
                                            <div className="text-xs text-gray-500 mb-2">{selectedAlgo.fullName}</div>
                                            <span className="inline-block px-2 py-0.5 rounded bg-white/60 text-xs font-bold text-gray-700 border border-gray-200">{selectedAlgo.type}</span>
                                        </div>
                                        <div className="p-5 flex-1 flex flex-col gap-4">
                                            <div><h4 className="text-xs font-bold text-gray-400 uppercase mb-1">概要</h4><p className="text-sm text-gray-700">{selectedAlgo.description}</p></div>
                                            <div className="bg-green-50 p-2 rounded border border-green-100"><h4 className="text-green-800 text-xs font-bold flex items-center gap-1 mb-1"><Icons.Check className="w-3 h-3"/> メリット</h4><ul className="text-xs text-gray-700 space-y-1">{selectedAlgo.pros.map((p,i)=><li key={i} className="flex gap-1"><span className="text-green-500">•</span>{p}</li>)}</ul></div>
                                            <div className="bg-red-50 p-2 rounded border border-red-100"><h4 className="text-red-800 text-xs font-bold flex items-center gap-1 mb-1"><Icons.Minus className="w-3 h-3"/> デメリット</h4><ul className="text-xs text-gray-700 space-y-1">{selectedAlgo.cons.map((c,i)=><li key={i} className="flex gap-1"><span className="text-red-400">•</span>{c}</li>)}</ul></div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        )}

                        {activeTab === 'relation' && (
                            <div className="max-w-4xl mx-auto flex flex-col items-center justify-center min-h-[500px] animate-in fade-in duration-500">
                                <div className="text-center mb-8">
                                    <h2 className="text-2xl font-bold text-gray-800">FAST + BRIEF = ORB</h2>
                                    <p className="text-gray-500 text-sm mt-2">高速な検出器(FAST)と高速な記述子(BRIEF)を改良・融合させた「いいとこ取り」の手法</p>
                                </div>
                                <div className="w-full bg-white rounded-xl shadow-lg border border-gray-100 p-8">
                                    <div className="flex flex-col md:flex-row gap-4 items-stretch justify-center relative mb-6">
                                        <div className="flex-1 bg-yellow-50 border border-yellow-200 rounded p-4 text-center">
                                            <Icons.Zap className="w-8 h-8 text-yellow-500 mx-auto mb-2"/>
                                            <h3 className="font-bold text-gray-800">FAST</h3>
                                            <div className="text-xs text-gray-500 mt-1">Detector</div>
                                            <div className="mt-2 text-xs bg-white p-2 rounded border border-red-100 text-red-500 text-left"><Icons.X className="w-3 h-3 inline mr-1"/>回転に弱い</div>
                                        </div>
                                        <div className="hidden md:flex items-center justify-center"><Icons.Plus className="w-6 h-6 text-gray-300"/></div>
                                        <div className="flex-1 bg-green-50 border border-green-200 rounded p-4 text-center">
                                            <Icons.Camera className="w-8 h-8 text-green-500 mx-auto mb-2"/>
                                            <h3 className="font-bold text-gray-800">BRIEF</h3>
                                            <div className="text-xs text-gray-500 mt-1">Descriptor</div>
                                            <div className="mt-2 text-xs bg-white p-2 rounded border border-red-100 text-red-500 text-left"><Icons.X className="w-3 h-3 inline mr-1"/>回転で値が変わる</div>
                                        </div>
                                    </div>
                                    <div className="flex justify-center mb-6"><div className="bg-white px-3 py-1 rounded-full border border-indigo-100 text-xs font-bold text-indigo-600 shadow-sm flex items-center gap-1"><Icons.GitMerge className="w-3 h-3"/> 改良・統合</div></div>
                                    <div className="bg-gradient-to-br from-red-50 to-indigo-50 border border-indigo-100 rounded-xl p-6 relative shadow-sm flex flex-col md:flex-row items-center gap-6">
                                        <div className="shrink-0 text-center"><div className="w-16 h-16 bg-white rounded-full shadow flex items-center justify-center border-4 border-indigo-100 mx-auto mb-2"><Icons.Maximize className="w-8 h-8 text-red-500"/></div><h2 className="text-2xl font-black text-gray-800">ORB</h2></div>
                                        <div className="flex-1 space-y-2">
                                            <h3 className="font-bold text-indigo-900">Oriented FAST and Rotated BRIEF</h3>
                                            <p className="text-xs text-gray-600">SIFTに匹敵する性能を持ちながら、特許フリーで計算コストも低い。</p>
                                            <div className="grid grid-cols-1 sm:grid-cols-2 gap-2 mt-2">
                                                <div className="bg-white/80 p-2 rounded border border-indigo-100 flex items-center gap-2"><Icons.RotateCw className="w-3 h-3 text-yellow-600"/><span className="text-xs">Oriented FAST (回転耐性付与)</span></div>
                                                <div className="bg-white/80 p-2 rounded border border-indigo-100 flex items-center gap-2"><Icons.RotateCw className="w-3 h-3 text-green-600"/><span className="text-xs">Rotated BRIEF (回転に合わせて記述)</span></div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        )}

                        {activeTab === 'learn' && (
                            <div className="grid grid-cols-1 md:grid-cols-4 gap-6 animate-in fade-in duration-500">
                                <div className="md:col-span-1 space-y-2">
                                    <h3 className="font-bold text-gray-500 text-xs uppercase tracking-wider mb-2 px-2">アルゴリズム選択</h3>
                                    {algorithms.map(algo => (
                                        <button key={algo.id} onClick={() => setLearnAlgoId(algo.id)} className={`w-full text-left px-4 py-3 rounded-lg border transition-all flex items-center gap-3 ${learnAlgoId === algo.id ? `${algo.color} ring-1 ring-indigo-200` : 'bg-white border-transparent hover:bg-white text-gray-600'}`}>
                                            {algo.icon}<span className={`font-bold text-sm ${learnAlgoId === algo.id ? 'text-indigo-900' : ''}`}>{algo.name}</span>
                                        </button>
                                    ))}
                                    <button onClick={() => setLearnAlgoId('hist')} className={`w-full text-left px-4 py-3 rounded-lg border transition-all flex items-center gap-3 ${learnAlgoId === 'hist' ? 'bg-gray-100 ring-1 ring-gray-300' : 'bg-white border-transparent hover:bg-white text-gray-600'}`}>
                                        <Icons.Activity className="w-4 h-4"/><span className="font-bold text-sm">Histogram (Common)</span>
                                    </button>
                                </div>

                                <div className="md:col-span-3 space-y-6">
                                    <div className="bg-white p-6 rounded-xl shadow border border-gray-100">
                                        <h2 className="text-xl font-bold text-gray-800 flex items-center gap-2">
                                            {learnAlgoId === 'hist' ? <Icons.Activity className="w-6 h-6 text-indigo-500"/> : learnAlgo.icon}
                                            {learnAlgoId === 'hist' ? '勾配ヒストグラム (記述子の基礎)' : learnAlgo.name}
                                        </h2>
                                        {learnAlgoId !== 'hist' && (
                                            <div className="mt-4 bg-gray-900 rounded p-3 text-xs font-mono text-gray-300 overflow-x-auto">
                                                <pre>{learnAlgo.opencv}</pre>
                                            </div>
                                        )}
                                    </div>

                                    <div className="bg-white rounded-xl shadow border border-gray-100 overflow-hidden">
                                        <div className="p-3 bg-indigo-50 border-b border-indigo-100 flex items-center gap-2 font-bold text-indigo-900">
                                            <Icons.Calculator className="w-4 h-4"/> 数値実験室 (Interactive Playground)
                                        </div>
                                        <div className="p-6">
                                            <p className="text-xs text-gray-500 mb-4">
                                                以下のグリッド数値を変更して、アルゴリズムがどう反応するかリアルタイムで確認できます。
                                            </p>
                                            {learnAlgoId === 'harris' && <HarrisPlayground />}
                                            {learnAlgoId === 'fast' && <FastPlayground />}
                                            {learnAlgoId === 'sift' && <SiftDogPlayground />}
                                            {learnAlgoId === 'orb' && (
                                                <div className="text-center text-sm text-gray-500 p-8 bg-gray-50 rounded">
                                                    ORBはFASTとBRIEF(回転対応版)の組み合わせです。<br/>
                                                    <span className="font-bold text-indigo-600 cursor-pointer underline" onClick={()=>setLearnAlgoId('fast')}>FASTの実験</span> と <span className="font-bold text-indigo-600 cursor-pointer underline" onClick={()=>setLearnAlgoId('hist')}>ヒストグラム(方向)の実験</span> を参照してください。
                                                </div>
                                            )}
                                            {learnAlgoId === 'brief' && (
                                                <div className="text-center text-sm text-gray-500 p-8 bg-gray-50 rounded">
                                                    BRIEFは単純なピクセル比較です。<br/>
                                                    FASTの実験での「明/暗」判定ロジックが基礎となります。
                                                </div>
                                            )}
                                            {learnAlgoId === 'hist' && <HistogramPlayground />}
                                        </div>
                                    </div>

                                    {learnAlgoId !== 'hist' && (
                                        <div className="bg-white p-6 rounded-xl shadow border border-gray-100">
                                            <h3 className="font-bold text-gray-700 mb-4 flex items-center gap-2"><Icons.Target className="w-4 h-4"/> 処理ステップ詳細</h3>
                                            <div className="space-y-6">
                                                {learnAlgo.steps?.map((step, i) => (
                                                    <div key={i} className="flex gap-4">
                                                        <div className="flex flex-col items-center">
                                                            <div className="w-6 h-6 rounded-full bg-indigo-100 text-indigo-600 font-bold flex items-center justify-center text-xs">{i+1}</div>
                                                            {i < (learnAlgo.steps?.length || 0)-1 && <div className="w-px h-full bg-indigo-100 my-1"></div>}
                                                        </div>
                                                        <div className="flex-1">
                                                            <h4 className="font-bold text-sm text-gray-800 mb-2">{step.title}</h4>
                                                            <div className="mb-3 max-w-sm">
                                                                <StepVisual algoId={learnAlgo.id} stepIndex={i} />
                                                            </div>
                                                            <p className="text-xs text-gray-600 leading-relaxed">{step.desc}</p>
                                                        </div>
                                                    </div>
                                                ))}
                                            </div>
                                        </div>
                                    )}
                                </div>
                            </div>
                        )}

                        {activeTab === 'sim' && (
                            <div className="grid grid-cols-1 lg:grid-cols-3 gap-6 animate-in fade-in duration-500">
                                <div className="bg-white rounded-xl shadow p-6 border border-gray-100 h-fit">
                                    <h2 className="text-lg font-bold mb-4 flex items-center gap-2 text-gray-700"><Icons.Settings className="w-5 h-5"/> 検証設定</h2>
                                    <div className="space-y-4">
                                        <div>
                                            <label className="text-xs font-bold text-gray-500 mb-2 block">アルゴリズム</label>
                                            <div className="space-y-2">
                                                {algorithms.map(algo => (
                                                    <button key={algo.id} onClick={() => setSimAlgoId(algo.id)} className={`w-full flex items-center p-2 rounded border text-left text-sm ${simAlgoId === algo.id ? `${algo.color} ring-1 ring-indigo-300` : 'bg-white hover:bg-gray-50'}`}>
                                                        <div className="mr-2">{algo.icon}</div>{algo.name}
                                                    </button>
                                                ))}
                                            </div>
                                        </div>
                                        <div className="pt-4 border-t">
                                            <div className="flex justify-between mb-1"><label className="text-xs font-bold text-gray-500 flex items-center gap-1"><Icons.RotateCw className="w-3 h-3"/> 回転</label><span className="text-xs font-mono">{Math.round(rotation)}°</span></div>
                                            <input type="range" min="0" max="360" value={rotation} onChange={(e) => { setRotation(Number(e.target.value)); setIsAutoRotate(false); }} className="w-full h-2 bg-gray-200 rounded-lg cursor-pointer" />
                                            <button onClick={() => setIsAutoRotate(!isAutoRotate)} className={`mt-2 w-full text-xs py-1 rounded border flex justify-center items-center gap-1 ${isAutoRotate ? 'bg-indigo-100 text-indigo-700' : 'bg-gray-50'}`}>{isAutoRotate ? '停止' : '自動回転'}</button>
                                        </div>
                                        <div>
                                            <div className="flex justify-between mb-1"><label className="text-xs font-bold text-gray-500 flex items-center gap-1"><Icons.ZoomIn className="w-3 h-3"/> スケール</label><span className="text-xs font-mono">x{scale.toFixed(2)}</span></div>
                                            <input type="range" min="0.5" max="2.0" step="0.1" value={scale} onChange={(e) => setScale(Number(e.target.value))} className="w-full h-2 bg-gray-200 rounded-lg cursor-pointer" />
                                        </div>
                                        <button onClick={() => { setRotation(0); setScale(1); setIsAutoRotate(false); }} className="w-full py-2 text-xs bg-gray-100 rounded hover:bg-gray-200 flex justify-center gap-2"><Icons.RefreshCw className="w-3 h-3"/> リセット</button>
                                    </div>
                                </div>
                                <div className="lg:col-span-2 flex flex-col">
                                    <div className="bg-white rounded-xl shadow border border-gray-100 p-1 flex-grow flex flex-col">
                                        <div className="p-3 bg-gray-50 border-b rounded-t text-sm font-bold text-gray-700 flex items-center gap-2"><Icons.Activity className="w-4 h-4 text-indigo-600"/> リアルタイム検証: {simAlgo.name}</div>
                                        <div className="flex-grow p-4 bg-gray-100 flex flex-col">
                                            <SimulationCanvas algoId={simAlgoId} rotation={rotation} scale={scale} />
                                            <div className="mt-4 bg-white p-4 rounded border shadow-sm">
                                                <h4 className="text-xs font-bold text-gray-700 mb-1">検証ポイント</h4>
                                                <p className="text-xs text-gray-600">{simAlgo.simNote}</p>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        )}
                    </div>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<FeatureComparisonApp />);
    </script>
</body>
</html>
